<!DOCTYPE html>
<html lang="ro" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Tempo - Sistem de management pentru centre de terapie">
    <title>SelecteazƒÉ utilizatorul - Tempo Admin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        tailwind.config = {
            darkMode: ['class', '[data-theme="dark"]'],
            theme: {
                extend: {
                    colors: {
                        primary: '#4A90E2',
                        secondary: '#F4E8D8',
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="icon.png" type="image/png">
    <link rel="stylesheet" href="netflix-style.css">
</head>
<body class="bg-gradient-to-br from-[#0f172a]  to-[#334155]">
    <!-- Skip Links for Accessibility -->
    <a href="#main-content" class="skip-link">Salt la con»õinut principal</a>
    <a href="#public-calendar" class="skip-link">Salt la calendar public</a>

    <div class="w-full max-w-7xl page-container">

        <main id="main-content" class="main-content" role="main" aria-label="Selectare utilizator">
            <div class="text-center mb-12">
                <img src="logo.png" alt="Tempo Logo" class="h-16 mx-auto mb-6" loading="eager">
                <h1 class="text-4xl font-bold text-gray-200 mb-3">Bine ai venit!</h1>
                <p class="text-xl text-gray-200 opacity-90">SelecteazƒÉ contul tƒÉu pentru a continua</p>
            </div>

            <div id="userCardsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6" role="list" aria-label="Lista utilizatori disponibili">
                </div>
        </main>

        <section id="public-calendar" class="public-calendar-container" aria-labelledby="publicCurrentPeriod">
            <header class="public-calendar-header">
                <h2 id="publicCurrentPeriod" class="dark:text-white">Calendar Public</h2>
                <div class="flex flex-wrap items-center gap-2">
                    <nav class="nav-controls" aria-label="Navigare calendar">
                        <button id="publicPrevBtn" class="nav-btn" title="Perioada precedentƒÉ" aria-label="Perioada precedentƒÉ">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="m15 18-6-6 6-6"/></svg>
                        </button>
                        <button id="publicTodayBtn" class="nav-btn" style="padding-left: 1rem; padding-right: 1rem; font-weight: 500;" aria-label="Mergi la azi">Azi</button>
                        <button id="publicNextBtn" class="nav-btn" title="Perioada urmƒÉtoare" aria-label="Perioada urmƒÉtoare">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="m9 18 6-6-6-6"/></svg>
                        </button>
                    </nav>
                    <div class="view-toggle" role="group" aria-label="Selectare vizualizare calendar">
                        <button class="view-btn active" data-view="month" aria-pressed="true" aria-label="Vizualizare lunƒÉ">LunƒÉ</button>
                        <button class="view-btn" data-view="week" aria-pressed="false" aria-label="Vizualizare sƒÉptƒÉm√¢nƒÉ">SƒÉptƒÉm√¢nƒÉ</button>
                        <button class="view-btn" data-view="day" aria-pressed="false" aria-label="Vizualizare zi">Zi</button>
                    </div>
                </div>
            </header>
            <div id="publicFilters" class="filters-container" role="group" aria-label="Filtre membri echipƒÉ">
                </div>
            <div id="publicCalendarView" class="calendar-view" role="region" aria-live="polite" aria-label="Vizualizare calendar">
                </div>
        </section>

    </div> <div class="powered-by-footer">
        <span class="text-gray-200 mr-2 opacity-70 text-xs">Powered by:</span>
        <img class="w-24" src="tempo-logo-dark.png" alt="Tempo" loading="lazy"/>
    </div>



    <div id="parentModal" class="parent-modal" role="dialog" aria-modal="true" aria-labelledby="parentModalTitle" aria-hidden="true">
        <div class="parent-modal-content">
            <div class="parent-modal-header">
                <h2 id="parentModalTitle">Profil Client</h2>
                <button id="closeParentModal" class="parent-modal-close" aria-label="√énchide dialog">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>
            <div class="parent-modal-body" id="parentModalContent">
                </div>
        </div>
    </div>

    <script type="module">
        // API Configuration
        const API_BASE = 'api.php';

        // Store username mapping (team member ID -> username)
        let usernameMap = {};

        // Performance Optimization: Debounce utility
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Performance Optimization: Request Animation Frame throttle
        function throttleRAF(func) {
            let running = false;
            return function(...args) {
                if (running) return;
                running = true;
                requestAnimationFrame(() => {
                    func(...args);
                    running = false;
                });
            };
        }

        // ==========================================================
        // --- TOAST NOTIFICATIONS ---
        // ==========================================================

        const toastIcons = {
            success: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>',
            error: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
            warning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>',
            info: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>'
        };

        let toastCounter = 0;

        /**
         * Show a toast notification
         * @param {string} type - Type of toast: 'success', 'error', 'warning', 'info'
         * @param {string} title - Toast title
         * @param {string} message - Toast message (optional)
         * @param {number} duration - Duration in ms (default 4000, 0 for permanent)
         */
        function showToast(type = 'info', title = '', message = '', duration = 4000) {
            const container = document.getElementById('toastContainer');
            if (!container) {
                console.warn('Toast container not found');
                return;
            }

            const toastId = `toast-${++toastCounter}`;
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.id = toastId;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'polite');
            toast.setAttribute('aria-atomic', 'true');

            const icon = toastIcons[type] || toastIcons.info;
            const closeIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';

            toast.innerHTML = `
                <div class="toast-icon" aria-hidden="true">${icon}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
                <button class="toast-close" aria-label="√énchide notificarea">${closeIcon}</button>
                ${duration > 0 ? `<div class="toast-progress" style="animation-duration: ${duration}ms" aria-hidden="true"></div>` : ''}
            `;

            container.appendChild(toast);

            // Close button handler
            const closeBtn = toast.querySelector('.toast-close');
            closeBtn.addEventListener('click', () => removeToast(toastId));

            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => removeToast(toastId), duration);
            }

            return toastId;
        }

        /**
         * Remove a toast notification
         * @param {string} toastId - ID of the toast to remove
         */
        function removeToast(toastId) {
            const toast = document.getElementById(toastId);
            if (!toast) return;

            toast.classList.add('toast-removing');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        /**
         * Convenience functions for different toast types
         */
        function showSuccessToast(title, message = '', duration = 4000) {
            return showToast('success', title, message, duration);
        }

        function showErrorToast(title, message = '', duration = 5000) {
            return showToast('error', title, message, duration);
        }

        function showWarningToast(title, message = '', duration = 4500) {
            return showToast('warning', title, message, duration);
        }

        function showInfoToast(title, message = '', duration = 4000) {
            return showToast('info', title, message, duration);
        }

        /**
         * Clear all toast notifications
         */
        function clearAllToasts() {
            const container = document.getElementById('toastContainer');
            if (container) {
                container.innerHTML = '';
            }
        }

        // Function to verify password via API
        async function verifyPassword(userId, password) {
            try {
                const formData = new FormData();
                // Use the mapped username instead of userId
                const username = usernameMap[userId] || userId;
                formData.append('username', username);
                formData.append('password', password);

                const response = await fetch(`${API_BASE}?action=login`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    return result.success;
                }
                return false;
            } catch (error) {
                console.error('Login error:', error);
                return false;
            }
        }

        // Store current selected month for schedule viewing
        let currentScheduleDate = new Date();

        const calendarState = {
            currentDate: new Date(),
            currentView: 'month',
            teamMembers: [],
            clients: [],
            events: [],
            activeFilters: [],
        };

        async function loadTeamMembers() {
            try {
                const response = await fetch(`${API_BASE}?path=data`);
                const data = await response.json();
                return data.teamMembers || [];
            } catch (error) {
                console.error('Error loading team members:', error);
                return [];
            }
        }

        async function loadAllData() {
            try {
                console.log('Loading data from API...');
                const response = await fetch(`${API_BASE}?path=data`);
                console.log('API response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('Response is not JSON:', text.substring(0, 200));
                    throw new Error('Server returned non-JSON response. Check api.php for errors.');
                }
                
                const data = await response.json();
                console.log('Data received:', data);
                console.log('Team members count:', data.teamMembers ? data.teamMembers.length : 0);
                
                calendarState.teamMembers = data.teamMembers || [];
                calendarState.clients = data.clients || [];
                calendarState.events = data.events || [];
                calendarState.activeFilters = (data.teamMembers || []).map(m => m.id);

                return data.teamMembers || [];
            } catch (error) {
                console.error('Error loading all data:', error);
                showErrorToast('Eroare la √ÆncƒÉrcarea datelor', 'Verifica»õi consola pentru detalii: ' + error.message, 6000);
                return [];
            }
        }

        async function loadClientData(clientId) {
            try {
                const [dataResponse, evolutionResponse] = await Promise.all([
                    fetch(`${API_BASE}?path=data`),
                    fetch(`${API_BASE}?path=evolution`)
                ]);
                
                const data = await dataResponse.json();
                const evolutionData = await evolutionResponse.json();
                
                const client = data.clients.find(c => c.id === clientId);
                if (!client) return null;
                
                const clientEvolution = evolutionData[clientId] || {};
                
                const clientEvents = data.events.filter(event => {
                    const clientIds = event.clientIds || (event.clientId ? [event.clientId] : []);
                    return clientIds.includes(clientId);
                });
                
                return {
                    client,
                    evolution: clientEvolution,
                    events: clientEvents,
                    teamMembers: data.teamMembers || []
                };
            } catch (error) {
                console.error('Error loading client data:', error);
                return null;
            }
        }

        function getRoleLabel(role) {
            const labels = {
                'therapist': 'Terapeut',
                'coordinator': 'Coordonator',
                'admin': 'Administrator',
                'parent': 'PƒÉrinte'
            };
            return labels[role] || role;
        }

        function getRoleClass(role) {
            return `role-${role}`;
        }

        async function renderUserCards() {
            const container = document.getElementById('userCardsContainer');

            // Load username mapping first
            try {
                const response = await fetch(`${API_BASE}?path=user-map`);
                if (response.ok) {
                    usernameMap = await response.json();
                    console.log('Username map loaded:', usernameMap);
                }
            } catch (error) {
                console.error('Failed to load username map:', error);
            }

            const teamMembers = await loadAllData();

            console.log('Rendering user cards...');
            console.log('Team members to render:', teamMembers);
            
            if (!teamMembers || teamMembers.length === 0) {
                console.warn('No team members found!');
                container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: white;"><p style="font-size: 1.2rem; margin-bottom: 1rem;">‚ö†Ô∏è Nu s-au gƒÉsit utilizatori</p><p style="opacity: 0.8;">Verifica»õi conexiunea la baza de date »ôi asigura»õi-vƒÉ cƒÉ existƒÉ utilizatori √Æn tabelul <code>team_members</code>.</p></div>';
                return;
            }
            
            let cardsHTML = '';

            // Add team member cards
            teamMembers.forEach(member => {
                const username = usernameMap[member.id] || member.id;
                cardsHTML += `
                    <div class="user-card bg-white dark:bg-gray-800 rounded-xl p-6 text-center shadow-lg" data-user-id="${member.id}" role="listitem" tabindex="0" aria-label="Cont ${member.name}, ${getRoleLabel(member.role)}">
                        <div class="user-avatar" style="background-color: ${member.color}" aria-hidden="true">
                            ${member.initials}
                        </div>
                        <h3 class="user-card-name">${member.name}</h3>
                        <p style="font-size: 0.875rem; opacity: 0.6; margin: 0.25rem 0 0.5rem;">@${username}</p>
                        <span class="role-badge ${getRoleClass(member.role)}" aria-label="Rol: ${getRoleLabel(member.role)}">${getRoleLabel(member.role)}</span>

                        <div class="password-input-container">
                            <input
                                type="password"
                                id="pass_${member.id}"
                                class="password-input"
                                placeholder="ParolƒÉ"
                                aria-label="ParolƒÉ pentru ${member.name}"
                                aria-required="true"
                            />
                            <button id="login_btn_${member.id}" class="login-btn" data-user-id="${member.id}" aria-label="IntrƒÉ √Æn contul pentru ${member.name}">
                                IntrƒÉ √Æn cont
                            </button>
                        </div>
                    </div>
                `;
            });

            // Add parent card
            cardsHTML += `
                <div class="user-card parent-card bg-white dark:bg-gray-800 rounded-xl p-6 text-center shadow-lg" role="listitem" tabindex="0" aria-label="Acces PƒÉrinte">
                    <div class="user-avatar" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%)" aria-hidden="true">
                        üë®‚Äçüë©‚Äçüëß
                    </div>
                    <h3 class="user-card-name">Acces PƒÉrinte</h3>
                    <span class="role-badge role-parent" aria-label="Rol: PƒÉrinte">PƒÉrinte</span>
                    <div class="parent-input-container">
                        <input
                            type="text"
                            id="clientCodeInput"
                            class="client-code-input"
                            placeholder="ex: cezar_2102"
                            aria-label="Cod client pentru acces pƒÉrinte"
                            aria-describedby="clientCodeHelp"
                        />
                        <span id="clientCodeHelp" class="sr-only">Introduce»õi codul unic al clientului pentru a vizualiza profilul</span>
                        <button id="viewProfileBtn" class="view-profile-btn" disabled aria-label="Vezi profil client" aria-disabled="true">
                            Vezi Profil
                        </button>
                    </div>
                </div>
            `;

            container.innerHTML = cardsHTML;

            // --- Logica de login "Netflix" ---
            const allCards = container.querySelectorAll('.user-card[data-user-id]');

            container.addEventListener('click', (e) => {
                const card = e.target.closest('.user-card[data-user-id]');

                if (!card) {
                    if (!e.target.closest('.user-card')) {
                        container.classList.remove('selection-active');
                        allCards.forEach(c => c.classList.remove('active'));
                    }
                    return;
                }

                const isAlreadyActive = card.classList.contains('active');

                container.classList.add('selection-active');
                allCards.forEach(c => c.classList.remove('active'));

                if (!isAlreadyActive) {
                    card.classList.add('active');
                    card.querySelector('.password-input').focus();
                } else {
                    container.classList.remove('selection-active');
                }
            });

            // Keyboard navigation for user cards
            allCards.forEach((card, index) => {
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        card.click();
                    } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = (index + 1) % allCards.length;
                        allCards[nextIndex].focus();
                    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = (index - 1 + allCards.length) % allCards.length;
                        allCards[prevIndex].focus();
                    }
                });
            });

            // --- AscultƒÉtori pentru submit-ul parolei ---
            teamMembers.forEach(member => {
                const loginBtn = document.getElementById(`login_btn_${member.id}`);
                const passInput = document.getElementById(`pass_${member.id}`);
                
                if (!loginBtn || !passInput) return;

                const handleLogin = async () => {
                    const userId = loginBtn.dataset.userId;
                    const password = passInput.value;
                    
                    if (!password) {
                        showWarningToast('ParolƒÉ lipsƒÉ', 'VƒÉ rugƒÉm introduce»õi parola!');
                        return;
                    }
                    
                    // Disable button and show loading state
                    loginBtn.disabled = true;
                    const originalText = loginBtn.textContent;
                    loginBtn.textContent = 'Se verificƒÉ...';
                    
                    const isValid = await verifyPassword(userId, password);
                    
                    if (isValid) {
                        selectUser(userId);
                    } else {
                        showErrorToast('Autentificare e»ôuatƒÉ', 'ParolƒÉ incorectƒÉ!');
                        passInput.value = '';
                        passInput.focus();
                        loginBtn.disabled = false;
                        loginBtn.textContent = originalText;
                    }
                };

                loginBtn.addEventListener('click', handleLogin);
                
                passInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleLogin();
                    }
                });
            });

            // Add parent card functionality
            setupParentCard();

            // InitializeazƒÉ calendarul public
            initPublicCalendar();
        }

        function setupParentCard() {
            const clientCodeInput = document.getElementById('clientCodeInput');
            const viewProfileBtn = document.getElementById('viewProfileBtn');

            clientCodeInput.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                viewProfileBtn.disabled = value.length === 0;
            });

            viewProfileBtn.addEventListener('click', async () => {
                const clientId = clientCodeInput.value.trim();
                if (!clientId) return;

                viewProfileBtn.disabled = true;
                viewProfileBtn.textContent = 'Se √ÆncarcƒÉ...';

                const clientData = await loadClientData(clientId);
                
                if (clientData) {
                    currentScheduleDate = new Date(); // Reset to current month
                    showParentModal(clientData);
                } else {
                    showErrorToast('Client negƒÉsit', 'Verifica»õi codul introdus.');
                }

                viewProfileBtn.disabled = false;
                viewProfileBtn.textContent = 'Vezi Profil';
            });

            clientCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !viewProfileBtn.disabled) {
                    viewProfileBtn.click();
                }
            });
        }

        function calculateMonthlyStats(events, clientId, year, month) {
            const monthEvents = events.filter(event => {
                const eventDate = new Date(event.date);
                return eventDate.getFullYear() === year && eventDate.getMonth() === month;
            });
            
            let totalHours = 0;
            let presentHours = 0;
            let absentHours = 0;
            let totalSessions = monthEvents.length;
            
            monthEvents.forEach(event => {
                if (!event.duration) return;
                const hours = event.duration / 60;
                totalHours += hours;
                
                const attendance = (event.attendance && event.attendance[clientId]) || 'present';
                if (attendance === 'present') {
                    presentHours += hours;
                } else {
                    absentHours += hours;
                }
            });
            
            return {
                totalSessions,
                totalHours: totalHours.toFixed(1),
                presentHours: presentHours.toFixed(1),
                absentHours: absentHours.toFixed(1),
                events: monthEvents
            };
        }

        function getAgeInMonths(birthDate, evalDate) {
            const birth = new Date(birthDate);
            const evalD = evalDate ? new Date(evalDate) : new Date();
            let months = (evalD.getFullYear() - birth.getFullYear()) * 12;
            months -= birth.getMonth();
            months += evalD.getMonth();
            return months <= 0 ? 0 : months;
        }
        
        function formatYearsMonths(years, months) {
            if (years === 0) return `${months} ${months === 1 ? 'luna' : 'luni'}`;
            if (months === 0) return `${years} ${years === 1 ? 'an' : 'ani'}`;
            const yearText = years === 1 ? 'an' : 'ani';
            const monthText = months === 1 ? 'luna' : 'luni';
            return `${years} ${yearText} si ${months} ${monthText}`;
        }

        function formatAgeInYearsMonths(totalMonths) {
            const years = Math.floor(totalMonths / 12);
            const months = totalMonths % 12;
            return formatYearsMonths(years, months);
        }

        function generatePortageSummaryHTML(clientData) {
            const client = clientData.client;
            const evaluations = clientData.evolution.evaluations;

            // VerificƒÉ dacƒÉ existƒÉ datele necesare
            if (!client.birthDate || !evaluations || Object.keys(evaluations).length === 0) {
                return ''; // Nu afi»ôa nimic dacƒÉ nu existƒÉ date
            }

            const birthDate = new Date(client.birthDate);
            const allDates = new Set();
            // AdunƒÉ toate datele de evaluare unice
            Object.values(evaluations).forEach(domain => {
                Object.keys(domain).forEach(date => allDates.add(date));
            });
            // SorteazƒÉ datele cronologic
            const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
            
            const results = [];
            sortedDates.forEach(date => {
                // Ob»õine toate scorurile (DA) pentru o anumitƒÉ datƒÉ
                const evalValues = Object.values(evaluations)
                    .map(domain => domain[date])
                    .filter(v => typeof v === 'number' && !isNaN(v));
                
                if (evalValues.length === 0) return; // ContinuƒÉ dacƒÉ nu existƒÉ scoruri pentru aceastƒÉ datƒÉ

                // CalculeazƒÉ media DA (V√¢rsta DezvoltƒÉrii)
                const avgDevAge = evalValues.reduce((a, b) => a + b, 0) / evalValues.length;
                // CalculeazƒÉ CA (V√¢rsta CronologicƒÉ) √Æn luni la data evaluƒÉrii
                const chronoAge = getAgeInMonths(birthDate, date); 
                
                if (chronoAge === 0) return; // EvitƒÉ √ÆmpƒÉr»õirea la zero
                
                // CalculeazƒÉ DQ (Coeficientul de Dezvoltare)
                const dq = (avgDevAge / chronoAge) * 100;
                results.push({ date, avgDevAge, chronoAge, dq });
            });

            if (results.length === 0) {
                return ''; // Nu s-au putut calcula rezultate
            }

            // GenereazƒÉ r√¢ndurile tabelului
            // Folosim clasa 'program-history-table' pentru stilizare consistentƒÉ
            const tableRows = results.map(r => {
                const color = r.dq < 70 ? '#ef4444' : r.dq < 85 ? '#f59e0b' : '#10b981'; // Ro»ôu, Galben, Verde
                return `<tr>
                    <td>${new Date(r.date).toLocaleDateString('ro-RO')}</td>
                    <td>${r.chronoAge.toFixed(1)} luni</td>
                    <td>${r.avgDevAge.toFixed(1)} luni</td>
                    <td style="font-weight:600;color:${color};">${r.dq.toFixed(1)}</td>
                </tr>`;
            }).join('');

            // ReturneazƒÉ HTML-ul complet al tabelului
            return `
                <div class="client-info-section">
                    <h3 class="section-title">Istoric Evolu»õie GeneralƒÉ (DQ)</h3>
                    <div style="overflow-x: auto;">
                        <table class="program-history-table">
                            <thead>
                                <tr>
                                    <th>Data EvaluƒÉrii</th>
                                    <th>V√¢rstƒÉ CronologicƒÉ (CA)</th>
                                    <th>V√¢rstƒÉ Dezvoltare (DA)</th>
                                    <th>Indice Dezvoltare (DQ)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

/**
 * Func»õie Helper (ACTUALIZATƒÇ)
 * GenereazƒÉ HTML-ul pentru afi»ôarea scorurilor (folosind stilul .score-btn)
 * @param {object | string} scoreData - Obiectul de scoruri (ex: {P: 1, +: 3}) sau un string (format vechi).
 */
function generateScoreHTML(scoreData) {
    let scores = scoreData;

    // 1. VerificƒÉ dacƒÉ datele sunt √Æn formatul vechi (string) »ôi converte»ôte-le
    if (typeof scores === 'string') {
        // Converte»ôte "P" √Æn { P: 1 } sau "P (1), + (3)" √Æn { P: 1, +: 3 }
        const convertedScores = { "0": 0, "-": 0, "P": 0, "+": 0 };
        if (scores.includes('(')) {
            // Format "P (1), + (3)"
            scores.split(',').forEach(part => {
                const match = part.match(/([0\-P+])\s*\((\d+)\)/);
                if (match && match[1] in convertedScores) {
                    convertedScores[match[1]] = parseInt(match[2], 10);
                }
            });
        } else if (scores.length > 0 && scores in convertedScores) {
            // Format vechi "P"
            convertedScores[scores] = 1;
        }
        scores = convertedScores;
    }

    // 2. AsigurƒÉ-te cƒÉ este un obiect valid, altfel creeazƒÉ unul gol
    if (typeof scores !== 'object' || scores === null) {
        scores = { "0": 0, "-": 0, "P": 0, "+": 0 };
    }

    // --- MODIFICARE AICI ---
    // Folosim clasa .program-score-display pentru aliniere (flex)
    // »ôi .program-score-buttons pentru a prelua spa»õierea (gap)
    let html = '<div class="program-score-display program-score-buttons">';
    
    const scoreOrder = ['0', '-', 'P', '+'];
    
    scoreOrder.forEach(key => {
        const count = scores[key] || 0;
        if (count > 0) {
            // Folosim clasa .score-btn pentru a prelua stilul
            // dar folosim un <div> √Æn loc de <button> »ôi adƒÉugƒÉm cursor: default
            html += `
                <div class="score-btn" data-score="${key}" style="cursor: default;">
                    <span class="score-badge">${count}</span>
                    <span class="score-label">${key}</span>
                </div>
            `;
        }
    });

    html += '</div>';
    
    // DacƒÉ nu existƒÉ niciun scor, returneazƒÉ un placeholder
    if (html === '<div class="program-score-display program-score-buttons"></div>') {
        return '<span class="note-program-no-score" style="font-weight: 600; color: #6b7280;">‚Äî</span>';
    }
    
    return html;
}

        function generateScheduleHTML(clientData) {
            const year = currentScheduleDate.getFullYear();
            const month = currentScheduleDate.getMonth();
            const monthName = currentScheduleDate.toLocaleString('ro-RO', { month: 'long', year: 'numeric' });

            const monthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
            let themeHTML = '';
            
            if (clientData.evolution && clientData.evolution.monthlyThemes) {
                const themeText = clientData.evolution.monthlyThemes[monthKey];
                
                if (themeText) {
                    themeHTML = `
                        <div class="monthly-theme-parent" style="background: var(--bg-card, #ffffff); border: 1px solid var(--border-color, #e5e7eb); border-left: 4px solid #4A90E2; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow, 0 2px 4px rgba(0,0,0,0.05));">
                            <h4 style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #4A90E2; text-transform: uppercase; font-weight: 700;">Tema lunii ${monthName}</h4>
                            <p style="white-space: pre-wrap; margin: 0; line-height: 1.6; color: var(--text-primary, #374151); font-size: 1rem;">
                                ${themeText.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
                            </p>
                        </div>
                    `;
                }
            }
            
            const stats = calculateMonthlyStats(clientData.events, clientData.client.id, year, month);
            
            // --- THIS IS THE FIX ---
            // The variable was incorrectly named 'contentHTML' instead of 'let html'
            let html = `
                <div class="client-info-section">
                    <h3 class="section-title">Program Lunar</h3>
                    
                    <div class="month-selector">
                        <button id="prevMonth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                        </button>
                        <span>${monthName}</span>
                        <button id="nextMonth">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                        </button>
                    </div>
                    
                    ${themeHTML} <div class="schedule-stats-grid">
                        <div class="stat-card">
                            <div class="stat-value hours">${stats.totalHours}</div>
                            <div class="stat-label">Ore Totale</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value present">${stats.presentHours}</div>
                            <div class="stat-label">Ore Prezent</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value absent">${stats.absentHours}</div>
                            <div class="stat-label">Ore Absent</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${stats.totalSessions}</div>
                            <div class="stat-label">Sesiuni</div>
                        </div>
                    </div>
            `;
            
            if (stats.events.length > 0) {
                const sortedEvents = stats.events.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                html += `<div class="schedule-list">`;
                sortedEvents.forEach(event => {
                    const eventDate = new Date(event.date);
                    const formattedDate = eventDate.toLocaleDateString('ro-RO', { 
                        weekday: 'short', 
                        day: 'numeric', 
                        month: 'short' 
                    });
                    
                    const attendance = (event.attendance && event.attendance[clientData.client.id]) || 'present';
                    const statusClass = attendance === 'present' ? 'present' : 'absent';
                    const statusText = attendance === 'present' ? 'Prezent' : 'Absent';
                    
                    const endTime = calculateEndTime(event.startTime, event.duration);
                    const hours = (event.duration / 60).toFixed(1);
                    
                    const teamMemberIds = event.teamMemberIds || (event.teamMemberId ? [event.teamMemberId] : []);
                    const therapistNames = teamMemberIds
                        .map(id => {
                            const therapist = clientData.teamMembers.find(m => m.id === id);
                            return therapist ? therapist.name : 'Terapeut necunoscut';
                        })
                        .join(', ');
                    
                    html += `
                        <div class="schedule-item">
                            <div>
                                <div class="schedule-date">${formattedDate}</div>
                                <div class="schedule-time">${event.startTime} - ${endTime} (${hours}h)</div>
                                <div class="schedule-time" style="margin-top: 0.25rem; color: #4A90E2;">
                                    ${therapistNames}
                                </div>
                            </div>
                            <div class="schedule-status">
                                <span class="status-badge ${statusClass}">${statusText}</span>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`;
            } else {
                html += `<p style="text-align: center; color: #6b7280; padding: 2rem;">Nu existƒÉ sesiuni programate √Æn aceastƒÉ lunƒÉ.</p>`;
            }
            
            html += `</div>`;
            
            return html;
        }
        function calculateEndTime(startTime, durationMinutes) {
            if (!startTime) return "N/A";
            const [hours, minutes] = startTime.split(':').map(Number);
            const totalMinutes = (hours * 60) + minutes + parseInt(durationMinutes, 10);
            const endHours = Math.floor(totalMinutes / 60) % 24;
            const endMinutes = totalMinutes % 60;
            return `${String(endHours).padStart(2, '0')}:${String(endMinutes).padStart(2, '0')}`;
        }

        function showParentModal(clientData) {
            const modal = document.getElementById('parentModal');
            const modalTitle = document.getElementById('parentModalTitle');
            const modalContent = document.getElementById('parentModalContent');

            modalTitle.textContent = `Profil - ${clientData.client.name}`;
            modal.setAttribute('aria-hidden', 'false');

            let contentHTML = `
                <div class="client-info-section">
                    <h3 class="section-title">Informa»õii Client</h3>
                    <div class="client-info-grid">
                        <div class="info-item">
                            <span class="info-label">Nume Complet</span>
                            <span class="info-value">${clientData.client.name}</span>
                        </div>
            `;

            if (clientData.client.email) {
                contentHTML += `
                    <div class="info-item">
                        <span class="info-label">Email</span>
                        <span class="info-value">${clientData.client.email}</span>
                    </div>
                `;
            }

            if (clientData.client.phone) {
                contentHTML += `
                    <div class="info-item">
                        <span class="info-label">Telefon</span>
                        <span class="info-value">${clientData.client.phone}</span>
                    </div>
                `;
            }

            if (clientData.client.birthDate) {
                const birthDate = new Date(clientData.client.birthDate);
                contentHTML += `
                    <div class="info-item">
                        <span class="info-label">Data Na»ôterii</span>
                        <span class="info-value">${birthDate.toLocaleDateString('ro-RO')}</span>
                    </div>
                `;
            }

            if (clientData.client.medical) {
                contentHTML += `
                    <div class="info-item">
                        <span class="info-label">Alergii sau medicatie</span>
                        <span class="info-value">${clientData.client.medical}</span>
                    </div>
                `;
            }

            contentHTML += `
                    </div>
                </div>
            `;

            contentHTML += generateScheduleHTML(clientData);

            if (clientData.evolution && clientData.evolution.evaluations && Object.keys(clientData.evolution.evaluations).length > 0) {
                contentHTML += `
                    <div class="client-info-section">
                        <h3 class="section-title">Evolu»õie Portage</h3>
                        <div class="chart-container-parent">
                            <canvas id="parentEvolutionChart"></canvas>
                        </div>
                    </div>
                `;
            }

            if (clientData.evolution && clientData.evolution.programHistory && clientData.evolution.programHistory.length > 0) {
                contentHTML += `
                    <div class="client-info-section">
                        <h3 class="section-title">Istoric Programe Recente</h3>
                        <div style="overflow-x: auto;">
                            ${generateProgramHistoryTable(clientData.evolution.programHistory)}
                        </div>
                    </div>
                `;
            }

            modalContent.innerHTML = contentHTML;
            modal.classList.add('active');

            // Focus management and focus trap for accessibility
            setTimeout(() => {
                const closeButton = document.getElementById('closeParentModal');
                if (closeButton) closeButton.focus();

                // Set up focus trap
                setupFocusTrap(modal);
            }, 100);

            document.getElementById('prevMonth').addEventListener('click', () => {
                currentScheduleDate.setMonth(currentScheduleDate.getMonth() - 1);
                updateScheduleSection(clientData);
            });
            
            document.getElementById('nextMonth').addEventListener('click', () => {
                currentScheduleDate.setMonth(currentScheduleDate.getMonth() + 1);
                updateScheduleSection(clientData);
            });

            if (clientData.evolution && clientData.evolution.evaluations && Object.keys(clientData.evolution.evaluations).length > 0) {
                setTimeout(() => renderEvolutionChart(clientData.evolution.evaluations), 100);
            }
        }

        function updateScheduleSection(clientData) {
            const scheduleSection = document.querySelector('.client-info-section:nth-child(2)');
            if (scheduleSection) {
                scheduleSection.outerHTML = generateScheduleHTML(clientData);
                
                document.getElementById('prevMonth').addEventListener('click', () => {
                    currentScheduleDate.setMonth(currentScheduleDate.getMonth() - 1);
                    updateScheduleSection(clientData);
                });
                
                document.getElementById('nextMonth').addEventListener('click', () => {
                    currentScheduleDate.setMonth(currentScheduleDate.getMonth() + 1);
                    updateScheduleSection(clientData);
                });
            }
        }


        /**
 * Func»õie Helper (NOUƒÇ)
 * GenereazƒÉ HTML-ul pentru afi»ôarea scorurilor sub formƒÉ de badge-uri.
 * @param {object | string} scoreData - Obiectul de scoruri (ex: {P: 1, +: 3}) sau un string (format vechi).
 */

        // √én: index.html (√Æn <script type="module">)
// ROL: Afi»ôeazƒÉ istoricul √Æn modalul "Acces PƒÉrinte"

function generateProgramHistoryTable(programHistory) {
    if (!programHistory || programHistory.length === 0) {
        return '<p class="error-message">Nu existƒÉ istoric de programe.</p>';
    }

    const sorted = [...programHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
    const grouped = {};
    sorted.forEach(entry => {
        if (!grouped[entry.programTitle]) grouped[entry.programTitle] = [];
        grouped[entry.programTitle].push(entry);
    });

    let html = `
        <table class="program-history-table">
            <thead>
                <tr>
                    <th>Program</th>
                    <th>Data</th>
                    <th style="text-align: left;">Scor</th> 
                </tr>
            </thead>
            <tbody>
    `;

    Object.entries(grouped).forEach(([programTitle, entries]) => {
        entries.slice(0, 10).forEach((entry, index) => {
            const formattedDate = new Date(entry.date).toLocaleDateString('ro-RO');
            
            // --- MODIFICARE AICI ---
            const scoreHtml = generateScoreHTML(entry.score); // Folosim noul helper
            // --- SF√ÇR»òIT MODIFICARE ---

            html += `<tr>`;
            if (index === 0) {
                html += `<td rowspan="${Math.min(entries.length, 10)}">${programTitle}</td>`;
            }
            html += `<td>${formattedDate}</td>`;
            
            // --- MODIFICARE AICI ---
            html += `<td style="text-align: left;">${scoreHtml}</td>`; // Afi»ôƒÉm HTML-ul
            // --- SF√ÇR»òIT MODIFICARE ---
            html += `</tr>`;
        });
    });

    html += `</tbody></table>`;
    return html;
}

        function renderEvolutionChart(evaluations) {
            const canvas = document.getElementById('parentEvolutionChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const colors = ['#4A90E2', '#FF6B6B', '#12C4D9', '#9B59B6', '#1DD75B', '#FFA500', '#E91E63'];
            const datasets = [];
            const allDates = new Set();

            Object.values(evaluations).forEach(values => {
                Object.keys(values).forEach(date => allDates.add(date));
            });
            const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));

            Object.entries(evaluations).forEach(([test, values], i) => {
                const color = colors[i % colors.length];
                datasets.push({
                    label: test,
                    data: sortedDates.map(date => values[date] ?? null),
                    borderColor: color,
                    backgroundColor: color,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4,
                    pointHoverRadius: 6
                });
            });

            new Chart(ctx, {
                type: 'line',
                data: { labels: sortedDates, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'bottom' },
                        title: { display: true, text: 'Evolu»õie Scoruri Portage', font: { size: 16 } }
                    },
                    scales: {
                        y: { beginAtZero: true, max: 100 }
                    }
                }
            });
        }

        function showPublicEventDetails(event) {
            const modal = document.getElementById('parentModal');
            const modalTitle = document.getElementById('parentModalTitle');
            const modalContent = document.getElementById('parentModalContent');

            modalTitle.textContent = `Detalii Eveniment Public`;

            // --- Build HTML for event details ---
            
            // Get Therapists
            const teamMemberIds = event.teamMemberIds || (event.teamMemberId ? [event.teamMemberId] : []);
            const therapists = teamMemberIds.map(id => {
                const member = calendarState.teamMembers.find(m => m.id === id);
                return member ? member : null;
            }).filter(Boolean); // Filter out any nulls

            // Get Clients
            const clientIds = event.clientIds || (event.clientId ? [event.clientId] : []);
            const clients = clientIds.map(id => {
                const client = calendarState.clients.find(c => c.id === id);
                return client ? client : null;
            }).filter(Boolean);

            // Format Date/Time
            const eventDate = new Date(event.date + 'T00:00:00'); // Ensure correct date parsing
            const formattedDate = eventDate.toLocaleDateString('ro-RO', { 
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
            });
            const endTime = calculateEndTime(event.startTime, event.duration);

            let contentHTML = `
                <div class="client-info-section">
                    <h3 class="section-title">Informa»õii Eveniment</h3>
                    <div class="client-info-grid">
                        <div class="info-item">
                            <span class="info-label">Nume</span>
                            <span class="info-value">${event.name}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Data</span>
                            <span class="info-value">${formattedDate}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Ora</span>
                            <span class="info-value">${event.startTime} - ${endTime}</span>
                        </div>
                        ${event.details ? `
                        <div class="info-item" style="grid-column: 1 / -1;">
                            <span class="info-label">Detalii</span>
                            <span class="info-value" style="white-space: pre-wrap;">${event.details}</span>
                        </div>` : ''}
                    </div>
                </div>
            `;

            if (therapists.length > 0) {
                contentHTML += `
                    <div class="client-info-section">
                        <h3 class="section-title">Terapeu»õi</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            ${therapists.map(m => `
                                <span style="background-color: ${m.color}; color: white; padding: 0.375rem 0.75rem; border-radius: 99px; font-size: 0.875rem; font-weight: 500;">
                                    ${m.name}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            if (clients.length > 0) {
                contentHTML += `
                    <div class="client-info-section">
                        <h3 class="section-title">Clien»õi Participan»õi</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                            ${clients.map(c => `
                                <span style="background-color: #f3f4f6; color: #1f2937; padding: 0.375rem 0.75rem; border-radius: 99px; font-size: 0.875rem; font-weight: 500;">
                                    ${c.name}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            modalContent.innerHTML = contentHTML;
            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');

            // Focus management and focus trap for accessibility
            setTimeout(() => {
                const closeButton = document.getElementById('closeParentModal');
                if (closeButton) closeButton.focus();

                // Set up focus trap
                setupFocusTrap(modal);
            }, 100);
        }

        function setupFocusTrap(modalElement) {
            // Get all focusable elements within the modal
            const focusableElements = modalElement.querySelectorAll(
                'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
            );

            if (focusableElements.length === 0) return;

            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];

            // Handle Tab key to trap focus
            const handleTabKey = (e) => {
                if (e.key !== 'Tab') return;

                if (e.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstFocusable) {
                        e.preventDefault();
                        lastFocusable.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastFocusable) {
                        e.preventDefault();
                        firstFocusable.focus();
                    }
                }
            };

            modalElement.addEventListener('keydown', handleTabKey);

            // Store the handler so we can remove it later
            modalElement._focusTrapHandler = handleTabKey;
        }

        function closeParentModal() {
            const modal = document.getElementById('parentModal');
            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');

            // Remove focus trap handler
            if (modal._focusTrapHandler) {
                modal.removeEventListener('keydown', modal._focusTrapHandler);
                delete modal._focusTrapHandler;
            }
        }

        function selectUser(userId) {
            sessionStorage.setItem('currentUserId', userId);
            window.location.href = 'dashboard.html';
        }

        // Close modal handlers
        document.getElementById('closeParentModal').addEventListener('click', closeParentModal);
        document.getElementById('parentModal').addEventListener('click', (e) => {
            if (e.target.id === 'parentModal') {
                closeParentModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('parentModal');
                if (modal.classList.contains('active')) {
                    closeParentModal();
                }
            }
        });

        // ==========================================================
        // --- LOGICA PENTRU CALENDARUL PUBLIC ---
        // ==========================================================

        function initPublicCalendar() {
            renderPublicCalendar();
            renderPublicFilters();

            document.getElementById('publicPrevBtn').addEventListener('click', () => handlePublicNavigation(-1));
            document.getElementById('publicNextBtn').addEventListener('click', () => handlePublicNavigation(1));
            document.getElementById('publicTodayBtn').addEventListener('click', navigateToPublicToday);
            
            document.querySelectorAll('.view-toggle .view-btn').forEach(btn => {
                btn.addEventListener('click', handlePublicViewChange);
            });
        }

        function renderPublicCalendar() {
            const { currentDate, currentView } = calendarState;
            updateCurrentPeriodLabel(currentDate, currentView);

            if (currentView === 'month') {
                renderPublicMonthView(handlePublicDayClick);
            } else if (currentView === 'week') {
                renderPublicWeekView();
            } else if (currentView === 'day') {
                renderPublicDayView();
            }
        }

        function renderPublicFilters() {
            const { teamMembers, activeFilters } = calendarState;
            const container = document.getElementById('publicFilters');
            if (!container) return;

            container.innerHTML = '';

            teamMembers.forEach(member => {
                const chip = document.createElement('button');
                chip.className = 'filter-chip';
                chip.style.color = member.color;
                chip.setAttribute('type', 'button');
                chip.setAttribute('role', 'switch');

                const isActive = activeFilters.includes(member.id);
                chip.setAttribute('aria-checked', isActive ? 'true' : 'false');
                chip.setAttribute('aria-label', `Filtru ${member.name}`);

                if (isActive) {
                    chip.classList.add('active');
                    chip.style.borderColor = member.color;
                }

                chip.innerHTML = `<span class="color-dot" style="background-color: ${member.color}" aria-hidden="true"></span><span>${member.name}</span>`;

                chip.addEventListener('click', () => {
                    const index = calendarState.activeFilters.indexOf(member.id);
                    if (index > -1) {
                        calendarState.activeFilters.splice(index, 1);
                    } else {
                        calendarState.activeFilters.push(member.id);
                    }
                    renderPublicFilters();
                    renderPublicCalendar();
                });

                // Keyboard navigation support
                chip.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        chip.click();
                    }
                });

                container.appendChild(chip);
            });
        }

        function handlePublicNavigation(direction) {
            const { currentDate, currentView } = calendarState;
            const newDate = new Date(currentDate);
            if (currentView === 'month') newDate.setMonth(newDate.getMonth() + direction);
            else if (currentView === 'week') newDate.setDate(newDate.getDate() + (7 * direction));
            else if (currentView === 'day') newDate.setDate(newDate.getDate() + direction);
            calendarState.currentDate = newDate;
            renderPublicCalendar();
        }

        function navigateToPublicToday() {
            calendarState.currentDate = new Date();
            renderPublicCalendar();
        }

        function handlePublicViewChange(e) {
            const newView = e.target.dataset.view;
            if (newView) {
                calendarState.currentView = newView;
                document.querySelectorAll('.view-toggle .view-btn').forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-pressed', 'false');
                });
                e.target.classList.add('active');
                e.target.setAttribute('aria-pressed', 'true');
                renderPublicCalendar();
            }
        }

        function handlePublicDayClick(date) {
            calendarState.currentDate = date;
            calendarState.currentView = 'day';
            document.querySelectorAll('.view-toggle .view-btn').forEach(b => {
                b.classList.remove('active');
                b.setAttribute('aria-pressed', 'false');
            });
            const dayBtn = document.querySelector('.view-toggle .view-btn[data-view="day"]');
            dayBtn.classList.add('active');
            dayBtn.setAttribute('aria-pressed', 'true');
            renderPublicCalendar();
        }

        function renderPublicMonthView(onDayClick) {
            const { currentDate, activeFilters } = calendarState;
            const container = document.getElementById('publicCalendarView');
            container.innerHTML = ''; 

            const monthView = document.createElement('div');
            monthView.className = 'month-view';
            const grid = document.createElement('div');
            grid.className = 'calendar-grid';

            const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            dayNames.forEach(day => {
                const header = document.createElement('div');
                header.className = 'day-header';
                header.textContent = day;
                grid.appendChild(header);
            });

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            let startDate = new Date(firstDay);
            const dayOfWeek = firstDay.getDay();
            const diff = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            startDate.setDate(startDate.getDate() - diff);

            for (let i = 0; i < 42; i++) {
                const currentDay = new Date(startDate);
                currentDay.setDate(startDate.getDate() + i);

                const dayCell = document.createElement('div');
                dayCell.className = 'day-cell';

                if (currentDay.getMonth() !== month) dayCell.classList.add('other-month');
                if (isWeekend(currentDay)) dayCell.classList.add('weekend');
                if (isToday(currentDay)) dayCell.classList.add('current-day');

                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = currentDay.getDate();
                dayCell.appendChild(dayNumber);

                const dayEvents = getEventsForDatePublic(currentDay);

                if (dayEvents.length > 0) {
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'event-dots';
                    const addedMembers = new Set(); 

                    dayEvents.forEach(event => {
                        const teamMemberIds = event.teamMemberIds || (event.teamMemberId ? [event.teamMemberId] : []);
                        teamMemberIds.forEach(memberId => {
                            if (addedMembers.has(memberId)) return; 
                            
                            const isFilterActive = activeFilters.length === 0 || activeFilters.includes(memberId);

                            if (isFilterActive) {
                                const member = calendarState.teamMembers.find(m => m.id === memberId);
                                if (member) {
                                    const dot = document.createElement('div');
                                    dot.className = 'event-dot';
                                    dot.style.backgroundColor = member.color;
                                    dot.title = member.name;
                                    dotsContainer.appendChild(dot);
                                    addedMembers.add(memberId);
                                }
                            }
                        });
                    });
                    dayCell.appendChild(dotsContainer);
                }

                dayCell.addEventListener('click', () => onDayClick(currentDay));
                grid.appendChild(dayCell);
            }

            monthView.appendChild(grid);
            container.appendChild(monthView);
        }

        function renderPublicWeekView() {
            const { currentDate } = calendarState;
            const container = document.getElementById('publicCalendarView');
            container.innerHTML = '';

            const weekView = document.createElement('div');
            weekView.className = 'week-view';

            const weekStart = getWeekStart(currentDate);
            const days = [];
            for (let i = 0; i < 7; i++) {
                const day = new Date(weekStart);
                day.setDate(weekStart.getDate() + i);
                days.push(day);
            }

            const header = document.createElement('div');
            header.className = 'week-header';
            header.innerHTML = '<div></div>'; 

            days.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header-week';
                dayHeader.innerHTML = `${day.toLocaleString('ro-RO', { weekday: 'short' })}<br>${day.getDate()}`;
                if (isToday(day)) dayHeader.classList.add('today');
                header.appendChild(dayHeader);
            });
            weekView.appendChild(header);

            const timeGrid = document.createElement('div');
            timeGrid.className = 'time-grid-container';

            for (let hour = 8; hour <= 20; hour++) {
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot';
                
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-label';
                timeLabel.textContent = formatHour(hour);
                timeSlot.appendChild(timeLabel);

                days.forEach(day => {
                    const hourCell = document.createElement('div');
                    hourCell.className = 'hour-cell';
                    const eventContainer = document.createElement('div');
                    eventContainer.className = 'event-container';
                    eventContainer.dataset.date = formatDateISO(day);
                    eventContainer.dataset.hour = hour;
                    hourCell.appendChild(eventContainer);
                    timeSlot.appendChild(hourCell);
                });
                timeGrid.appendChild(timeSlot);
            }
            weekView.appendChild(timeGrid);
            
            renderEventsInPublicGrid(days, weekView);
            container.appendChild(weekView);
        }

        function renderPublicDayView() {
            const { currentDate } = calendarState;
            const container = document.getElementById('publicCalendarView');
            container.innerHTML = '';

            const dayView = document.createElement('div');
            dayView.className = 'day-view'; 

            const days = [currentDate];

            const header = document.createElement('div');
            header.className = 'week-header';
            header.innerHTML = '<div></div>'; 

            const dayHeader = document.createElement('div');
            dayHeader.className = 'day-header-week';
            dayHeader.innerHTML = currentDate.toLocaleString('ro-RO', { weekday: 'long', month: 'long', day: 'numeric' });
            if (isToday(currentDate)) dayHeader.classList.add('today');
            header.appendChild(dayHeader);
            dayView.appendChild(header);

            const timeGrid = document.createElement('div');
            timeGrid.className = 'time-grid-container';

            for (let hour = 8; hour <= 20; hour++) {
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot';
                
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-label';
                timeLabel.textContent = formatHour(hour);
                timeSlot.appendChild(timeLabel);

                const hourCell = document.createElement('div');
                hourCell.className = 'hour-cell';
                const eventContainer = document.createElement('div');
                eventContainer.className = 'event-container';
                eventContainer.dataset.date = formatDateISO(currentDate);
                eventContainer.dataset.hour = hour;
                hourCell.appendChild(eventContainer);
                timeSlot.appendChild(hourCell);
                
                timeGrid.appendChild(timeSlot);
            }
            dayView.appendChild(timeGrid);

            renderEventsInPublicGrid(days, dayView);
            container.appendChild(dayView);
        }

        function renderEventsInPublicGrid(days, viewElement) {
            const { activeFilters, teamMembers, clients } = calendarState;
            
            const visibleTherapists = activeFilters.length === 0 
                ? teamMembers 
                : teamMembers.filter(m => activeFilters.includes(m.id));
            
            if (visibleTherapists.length === 0) return;
            
            const trackWidth = 100 / visibleTherapists.length;
            
            days.forEach((day) => {
                const dateStr = formatDateISO(day);
                const dayEvents = getEventsForDatePublic(day);
                
                const eventsByTherapist = {};
                visibleTherapists.forEach(therapist => {
                    eventsByTherapist[therapist.id] = [];
                });
                
                dayEvents.forEach(event => {
                    const teamMemberIds = event.teamMemberIds || (event.teamMemberId ? [event.teamMemberId] : []);
                    teamMemberIds.forEach(memberId => {
                        if (eventsByTherapist[memberId]) {
                            eventsByTherapist[memberId].push(event);
                        }
                    });
                });
                
                visibleTherapists.forEach((therapist, therapistIndex) => {
                    const therapistEvents = eventsByTherapist[therapist.id] || [];
                    
                    therapistEvents.forEach((event) => {
                        if (!event.startTime || !event.duration) return;

                        const timeParts = event.startTime.split(':').map(Number);
                        const startHour = timeParts[0] || 0;
                        const startMinute = timeParts[1] || 0;
                        const formattedStartTime = `${String(startHour).padStart(2, '0')}:${String(startMinute).padStart(2, '0')}`;
                        
                        const containerSelector = `.event-container[data-date="${dateStr}"][data-hour="${startHour}"]`;
                        const container = viewElement.querySelector(containerSelector);
                        
                        if (!container) return;
                        
                        const eventBlock = document.createElement('div');
                        eventBlock.className = 'event-block';
                        
                        const endTime = calculateEndTime(event.startTime, event.duration);
                        
                        const topOffset = (startMinute / 60) * 120;
                        const height = (event.duration / 60) * 120;
                        eventBlock.style.top = `${topOffset}px`;
                        eventBlock.style.height = `${height}px`;
                        eventBlock.style.width = `${trackWidth}%`;
                        eventBlock.style.left = `${trackWidth * therapistIndex}%`;

                        if (event.isPublic) {
                            eventBlock.classList.add('admin-view');
                            eventBlock.style.backgroundColor = therapist.color;
                            
                            const clientIds = event.clientIds || (event.clientId ? [event.clientId] : []);
                            const clientNames = clientIds.map(id => {
                                const client = calendarState.clients.find(c => c.id === id);
                                return client ? client.name : '';
                            }).filter(Boolean).join(', ');

                            eventBlock.innerHTML = `
                                <div class="event-time">${formattedStartTime} - ${endTime}</div>
                                <div class="event-title">${event.name}</div>
                                ${clientNames ? `<div class="event-clients">${clientNames}</div>` : ''}
                            `;

                            eventBlock.addEventListener('click', () => {
                                showPublicEventDetails(event);
                            });
                            
                        } else {
                            eventBlock.classList.add('public-view-private'); 
                            eventBlock.style.borderColor = therapist.color;
                            eventBlock.style.color = therapist.color;
                            
                            eventBlock.innerHTML = `
                                <div class="event-time">${formattedStartTime} - ${endTime}</div>
                                <div class="event-title">Ocupat</div>
                            `;
                        }
                        
                        container.appendChild(eventBlock);
                    });
                });
            });
        }

        // --- Func»õii Helper ---

        function getEventsForDatePublic(dateObj) {
            const { events, activeFilters } = calendarState;
            const dateStr = formatDateISO(dateObj);
            
            return events.filter(event => {
                if (event.date !== dateStr) return false;
                if (activeFilters.length === 0) return true;
                
                const teamMemberIds = event.teamMemberIds || (event.teamMemberId ? [event.teamMemberId] : []);
                return teamMemberIds.some(id => activeFilters.includes(id));
            });
        }

        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay(); 
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function isToday(date) {
            const today = new Date();
            return date.getDate() === today.getDate() &&
                   date.getMonth() === today.getMonth() &&
                   date.getFullYear() === today.getFullYear();
        }

        function isWeekend(date) {
            const day = date.getDay();
            return day === 0 || day === 6;
        }

        function formatDateISO(date) {
    // FIX: Use local date parts to avoid timezone conversion errors from .toISOString()
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

        function formatHour(hour) {
            return `${String(hour).padStart(2, '0')}:00`;
        }

        function updateCurrentPeriodLabel(date, view) {
            const labelEl = document.getElementById('publicCurrentPeriod');
            if (!labelEl) return;
            
            let label = '';
            const ro = 'ro-RO';
            if (view === 'month') {
                label = date.toLocaleString(ro, { month: 'long', year: 'numeric' });
            } else if (view === 'week') {
                const start = getWeekStart(date);
                const end = new Date(start);
                end.setDate(end.getDate() + 6);
                label = `${start.toLocaleDateString(ro, {day: 'numeric', month: 'short'})} - ${end.toLocaleDateString(ro, {day: 'numeric', month: 'short', year: 'numeric'})}`;
            } else if (view === 'day') {
                label = date.toLocaleString(ro, { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
            }
            labelEl.textContent = label;
        }

        // --- Ini»õializare ---

        // Initialize theme
        const savedTheme = localStorage.getItem('calendar-theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // Load users on page load
        renderUserCards();
    </script>
    <div id="globalLoader" class="loader-backdrop">
        <div class="loader-spinner"></div>
        <span>Se √ÆncarcƒÉ...</span>
    </div>

    <!-- Toast Notification Container -->
    <div id="toastContainer" class="toast-container"></div>
</body>
</html>